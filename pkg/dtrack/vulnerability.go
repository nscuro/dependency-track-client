package dtrack

import (
	"context"
	"fmt"
	"regexp"
)

const (
	SeverityCritical   = "CRITICAL"
	SeverityHigh       = "HIGH"
	SeverityMedium     = "MEDIUM"
	SeverityLow        = "LOW"
	SeverityInfo       = "INFO"
	SeverityUnassigned = "UNASSIGNED"
)

type VulnerabilitySource string

const (
	NVD           VulnerabilitySource = "NVD"
	OSSIndex      VulnerabilitySource = "OSSIndex"
	UnknownSource VulnerabilitySource = ""
)

var (
	regexCVE  = regexp.MustCompile("^CVE-[\\d]+-[\\d]+$")
	regexUUID = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
)

type Vulnerability struct {
	UUID     string `json:"uuid"`
	VulnID   string `json:"vulnId"`
	Severity string `json:"severity"`
}

type VulnerabilityService interface {
	GetAll(ctx context.Context) ([]Vulnerability, error)
	GetAllForProject(ctx context.Context, projectUUID string) ([]Vulnerability, error)
	GetByUUID(ctx context.Context, uuid string) (*Vulnerability, error)
	GetByVulnID(ctx context.Context, vulnID string, source VulnerabilitySource) (*Vulnerability, error)
}

type vulnerabilityServiceImpl struct {
	client *Client
}

func (v vulnerabilityServiceImpl) GetAll(ctx context.Context) ([]Vulnerability, error) {
	panic("implement me")
}

func (v vulnerabilityServiceImpl) GetAllForProject(ctx context.Context, projectUUID string) ([]Vulnerability, error) {
	panic("implement me")
}

func (v vulnerabilityServiceImpl) GetByUUID(ctx context.Context, uuid string) (*Vulnerability, error) {
	res, err := v.client.restClient.R().
		SetContext(ctx).
		SetResult(&Vulnerability{}).
		SetPathParams(map[string]string{
			"uuid": uuid,
		}).
		Get("/api/v1/vulnerability/{uuid}")
	if err != nil {
		return nil, err
	}

	if err = v.client.checkResponseStatus(res, 200); err != nil {
		return nil, err
	}

	vulnerability, ok := res.Result().(*Vulnerability)
	if !ok {
		return nil, ErrInvalidResponseType
	}

	return vulnerability, nil
}

func (v vulnerabilityServiceImpl) GetByVulnID(ctx context.Context, vulnID string, source VulnerabilitySource) (*Vulnerability, error) {
	if source == UnknownSource {
		return nil, fmt.Errorf("unknown vulnerability source")
	}

	res, err := v.client.restClient.R().
		SetContext(ctx).
		SetResult(&Vulnerability{}).
		SetPathParams(map[string]string{
			"source": string(source),
			"vulnId": vulnID,
		}).
		Get("/api/v1/vulnerability/source/{source}/vuln/{vulnId}")
	if err != nil {
		return nil, err
	}

	if err = v.client.checkResponseStatus(res, 200); err != nil {
		return nil, err
	}

	vulnerability, ok := res.Result().(*Vulnerability)
	if !ok {
		return nil, ErrInvalidResponseType
	}

	return vulnerability, nil
}

// FIXME: Move this to internal package
func (c Client) GuessVulnerabilitySource(vulnID string) VulnerabilitySource {
	if regexCVE.MatchString(vulnID) {
		return NVD
	} else if regexUUID.MatchString(vulnID) {
		return OSSIndex
	}
	return UnknownSource
}
